Задание 1.

Чтобы число было четным, необходимо, чтобы оно было целым. Говорить о четности/нечётности дробных чисел некорректно с точки зрения математики.
В задании предложена реализация функции проверки числ на чётность. 

Плюсы. Данная реализация очень проста и отлично работает с целыми числами. Кроме того, проверка будет осуществляться крайне быстро вне зависимости от размера числа (есть лишь 
машинное ограничение на длину числа). Передача неверного типа (кроме float) вызовет исключение TypeError.

Минусы. Переданное число типа float даст в результате False (кроме случаев, где целая часть кратна 0, а дробна равна 0), но, 
как указано ранее, говорить о четности/нечетности числа, не являющегося целым, некорректно.

Вторая реализация на вход должна принимать целое число, но благодаря нестрогости аннотаций может принять объект любого типа.
Плюсы. Нет ошибки несоответствия типов - любой объект станет строковым. Передача неправильного объекта вызовет ValueError.
Учтено, что вещественное число в общем случае - не целое.

Минусы. Время выполнения растёт с длиной строки - необходимо проверять, все ли элементы переданного объекта - цифры 
(нулевым элементом может быть цифра или минус, остальные - только цифры). 

Задание 2.
Первая реализация основана на кортежах, так как они являются неизменяемыми итерируемыми объектами, способными хранить данные любых типов.
Плюсы. Блокировка доступа к переменным снаружи благодаря "_" в начале имени переменных класса. Кроме того, реализация достаточно простая.
Очередь работает только с одинм типом данных, который закрепляется после ввода первого элемента.
Минусы. Реализация на кортежах достаточно медленная в сравнении с втроенным классом библиотеки Queue.

Вторая реализация - на структуре данных "Связанный список", причем двунаправленный.
Плюсы: скорость работы. Надёжность структуры.
Минусы: относительная сложность кода. Наличие доступа снаружи к внутренним переменным.

Задание 3.
Представлена сортировка по алгоритму QuickSort. Выполняется проверка на входе на то, является ли массив отсортированным. Если да, то нет необходимости
выполнять сортировку. Если массив отсортирован по убыванию, проверка также это учтёт и развернёт массив. В проиивном случае будет выполнена сортировка. 
Данный метод наиболее оптимален, поскольку сложность по времени ограничена O(n*log(n)), (n - размер массива.) 